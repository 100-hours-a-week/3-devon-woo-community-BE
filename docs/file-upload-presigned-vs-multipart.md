# 파일 업로드 아키텍처 비교: Presigned URL vs Multipart Upload

## 1. 공통 시나리오 개요

- 대상: 이미지(프로필/게시글 썸네일 등)를 오브젝트 스토리지(S3, GCS 등)에 저장
- 요구사항
  - DB에는 메타데이터(파일명, 경로, 사이즈, MIME, 소유자, 유효기간 등) 저장
  - CDN을 통한 빠른 제공
  - 파일 후처리(리사이즈, 썸네일, 워터마크 등)
  - 다양한 삭제 전략 지원(소프트 삭제, 지연 삭제, 버전 관리 등)

---

## 2. Presigned URL 방식

### 2.1 저장 흐름

1. 클라이언트가 업로드 사전 요청  
   `POST /files/presign` (body: 파일명, 타입, 예상 크기, 카테고리 등)
2. 서버가 스토리지용 키(key)와 메타 정보 생성  
   예: `images/{userId}/{uuid}.jpg`  
   DB에 “업로드 예정” 상태의 File 레코드 생성
3. 서버가 스토리지에 Presigned URL 생성  
   - HTTP 메서드: `PUT` or `POST`  
   - 만료 시간: 수 분 단위  
   - 필요한 헤더/쿼리 파라미터 포함
4. 클라이언트가 Presigned URL로 스토리지에 직접 업로드  
   - 서버는 파일 바디를 받지 않음  
   - 업로드 성공/실패 여부를 클라이언트에서 서버로 알려주도록 프로토콜 설계
5. 서버가 업로드 완료 확인 및 DB 메타데이터 확정  
   - 클라이언트가 `POST /files/complete` 호출 (파일 키, 사이즈 등 전달)  
   - 또는 스토리지 이벤트(S3 Event, Pub/Sub 등)로 비동기 확인  
   - File 레코드 상태: `UPLOADED` 로 변경

### 2.2 DB 메타데이터 저장 흐름

- 사전 단계: Presign 요청 시  
  `file_id`, `owner_id`, `storage_key`, `expected_content_type`, `status=PENDING`
- 업로드 완료 단계  
  실제 `content_length`, `checksum`, `uploaded_at` 업데이트  
  `status=UPLOADED` 로 전환
- 추가 메타  
  버전(리비전), 접근 레벨(공개/비공개), 태그(게시글 ID 등) 저장

### 2.3 장단점

- 장점
  - 서버 부하 감소: 파일 데이터가 서버를 거치지 않음 (네트워크/CPU/메모리 절약)
  - 확장성 우수: 트래픽이 증가해도 애플리케이션 서버 스케일 압박이 적음
  - 대용량 파일에 유리: 클라이언트 ↔ 스토리지 간 대역폭만 확보하면 됨
  - 네트워크 경로 단순화: 서버는 메타데이터와 권한만 관리
- 단점
  - 클라이언트 구현 복잡성 증가: Presigned URL 사용법, CORS, 헤더 처리 등을 알아야 함
  - 업로드 성공/실패 동기화 로직 필요  
    업로드 실패 시 “PENDING” 레코드 정리 작업 필요
  - 세밀한 유효성 검사 어려움  
    서버가 실제 바이트를 보지 못해, 파일 내용 기반 검사(바이러스 스캔 등)는 별도 파이프라인 필요

### 2.4 도입 시기

- 적합한 시기/조건
  - 이미지/동영상 등 대용량 파일이 많고, 서버 네트워크 비용이 부담되는 경우
  - 모바일/웹 클라이언트가 충분히 고도화되어 있고, 복잡한 업로드 프로토콜도 구현 가능할 때
  - 향후 트래픽 성장이 예상되고 수평 확장이 중요한 서비스
- 초기에는 굳이 안 써도 되는 경우
  - 파일 크기가 작고, 트래픽이 크지 않은 MVP 단계
  - 서버/클라이언트 모두 단순한 구현을 선호할 때

---

## 3. Multipart Upload (서버 경유 업로드) 방식

여기서는 “클라이언트 → 서버(HTTP multipart/form-data) → 서버가 스토리지에 업로드” 구조를 의미합니다.

### 3.1 저장 흐름

1. 클라이언트가 파일 업로드 요청  
   `POST /files` (multipart/form-data, `file`, `type`, `resourceId` 등)
2. 서버에서 파일 바디 수신  
   - 요청 검증(인증/인가, MIME/확장자, 파일 크기 제한 등)  
   - 옵션: 이미지 헤더 읽어서 실질적인 파일 타입 검증
3. 서버가 스토리지에 업로드  
   - SDK 사용: `putObject` 또는 서버에서 S3의 multipart upload API 사용 (대용량일 경우)  
   - 업로드 키(key) 생성 및 예외 처리
4. 업로드 성공 시 DB 메타데이터 저장  
   - `file_id`, `storage_key`, `content_type`, `size`, `owner_id`, `created_at` 등
5. 서버가 업로드 결과 응답  
   - 파일 URL 또는 `file_id` 반환

### 3.2 DB 메타데이터 저장 흐름

- 서버가 업로드 후 즉시 기록  
  업로드 성공 시점에 트랜잭션 내에서 메타데이터 저장
- 필요시 비즈니스 엔터티와 연결  
  게시글/사용자/댓글 등과 `file_id`를 릴레이션으로 저장
- 서버에서 실제 파일을 들고있기 때문에  
  content-type, 이미지 해상도, EXIF 정보 등도 바로 계산/저장 가능

### 3.3 장단점

- 장점
  - 구현 단순: 클라이언트는 일반적인 파일 업로드만 구현하면 됨
  - 서버에서 강력한 검증 가능  
    파일 타입, 크기, 안전성(바이러스 스캔, 민감 정보 탐지 등)
  - 업로드/메타데이터/비즈니스 로직을 하나의 트랜잭션으로 묶기 쉬움
- 단점
  - 서버 부하 증가  
    모든 파일이 서버를 통과 → 네트워크, 메모리, CPU 부담  
    대용량 업로드/동시 업로드에 취약
  - 스케일링 비용 증가  
    서버 수평 확장, 로드밸런싱, 업로드 전용 서버 분리 등의 추가 고려 필요
  - 업로드 시간이 늘어나면 API 응답 지연

### 3.4 도입 시기

- 적합한 시기/조건
  - 서비스 초기, 파일 크기와 트래픽이 크지 않은 경우
  - 보안/검증이 매우 중요하고, 서버 측에서 파일 내용을 반드시 검사해야 하는 경우
  - 클라이언트가 단순해야 하는 환경(레거시, 제3자 클라이언트 등)
- 점진적으로 Presigned URL로 전환 고려
  - 업로드 트래픽 증가, 응답 지연 발생, 서버 네트워크 비용 상승 시
  - “파일 업로드 전용 서비스”로 분리하면서 Presigned URL 도입

---

## 4. 두 방식의 비교 요약

- 책임 분리
  - Presigned URL: 업로드 I/O는 스토리지, 인증/메타는 서버
  - Multipart: 업로드부터 검증/메타까지 모두 서버
- 확장성
  - Presigned URL: 대규모 트래픽/대용량에 유리
  - Multipart: 특정 수준 이상부터 서버 확장이 부담
- 보안/검증
  - Presigned URL: 사전 검증 위주, 사후 비동기 검사 필요
  - Multipart: 요청 시점에 동기 검증 가능
- 클라이언트 복잡도
  - Presigned URL: 복잡 (CORS, 헤더, 에러 처리 등)
  - Multipart: 단순 (기본 파일 업로드)

---

## 5. CDN 및 URL 제공 단계

### 5.1 스토리지 → CDN 구성

- 스토리지 버킷을 CDN 오리진으로 설정  
  예: S3 버킷 → CloudFront, Cloudflare, Akamai 등
- 공개/비공개 버킷 전략
  - 공개 컨텐츠: 퍼블릭 읽기 또는 오리진 액세스 아이덴티티(Origin Access Identity) + CDN 경유
  - 비공개 컨텐츠: 서명된 CDN URL, 쿠키 기반 인증 등

### 5.2 URL 설계

- 저장 키 구조
  - `images/{entityType}/{entityId}/{uuid}.{ext}`
  - 썸네일/리사이즈 버전: `images/{entityId}/{uuid}_w400.jpg` 등
- 제공 URL
  - CDN 도메인 사용: `https://cdn.example.com/images/...`
  - 프록시 API 통한 제공(접근 제어 필요 시):  
    `GET /files/{fileId}` → 내부에서 스토리지/CDN URL 반환 또는 리다이렉트
- 캐싱 전략
  - `Cache-Control`, `ETag` 설정
  - 변경 불변(immutable) URL 전략: 파일 변경 시 새 키/URL 사용

---

## 6. 파일 후처리 단계

### 6.1 대표 후처리 항목

- 이미지 처리
  - 리사이즈/크롭/썸네일 생성
  - 포맷 변환(WebP/AVIF 등)
  - 워터마크/오버레이
- 콘텐츠 검사
  - 바이러스 스캔
  - 부적절 이미지(Adult/Violence) 검출
- 메타 정보 추출
  - EXIF, 해상도, 색 공간 등 저장

### 6.2 처리 방식

- 동기 처리 (요청 흐름 안에서)
  - Multipart 업로드 방식에서는 서버 내에서 바로 처리 가능
  - 장점: 업로드 완료 시점에 이미 후처리된 상태
  - 단점: 응답 시간이 길어지고 장애 영향 범위가 커짐
- 비동기 처리 (이벤트 기반)
  - Presigned URL 방식에 특히 적합
  - 흐름 예:
    1. 업로드 완료 시 스토리지 이벤트 발생
    2. 큐/스트림으로 작업자(Worker/Lambda 등)에 전송
    3. 후처리 수행 후 결과(새 파일 키, 썸네일 키 등)를 DB에 반영
  - 장점: API 응답 빠르고, 확장성/격리도 좋음
  - 단점: 업로드 직후에는 썸네일이 없을 수 있음 → UI에서 로딩 상태 처리 필요

---

## 7. 파일 삭제 전략

### 7.1 기본 개념

- 실제 삭제(Physical Delete): 스토리지 객체 삭제
- 소프트 삭제(Soft Delete): DB에서만 상태 플래그로 삭제 표시, 실제 파일은 남김
- 지연 삭제(Delayed Delete): 일정 기간 후 실제 삭제

### 7.2 전략별 설계

- 소프트 삭제
  - File 레코드에 `deleted_at`, `is_deleted` 컬럼 추가
  - 비즈니스 레벨에서 “삭제된 파일은 노출하지 않기” 규칙으로 처리
  - 롤백/감사(로그) 목적에 유리
- 지연 삭제
  - 삭제 요청 시: `deleted_at` 설정, 실제 스토리지 삭제는 배치/워커가 수행
  - 배치 작업:
    - `deleted_at < now() - gracePeriod` 인 레코드의 `storage_key`를 스토리지에서 삭제
    - 이후 완전 삭제 플래그 또는 레코드 제거
- 즉시 삭제
  - 민감 정보/법적 사유 등으로 즉시 파기 필요 시
  - DB 트랜잭션 내에서 스토리지 삭제 + 레코드 삭제/갱신

### 7.3 Presigned URL / Multipart에 따른 차이

- 공통
  - 삭제는 두 방식 모두에서 스토리지 API를 통해 수행
  - URL 제공 방식(CDN, 프록시)에 따라 캐시 무효화 고려 필요
- 추가 고려 사항
  - Presigned URL 방식에서는, “업로드 실패” 또는 “업로드를 취소한” `PENDING` 레코드/파일 정리가 중요  
    일정 시간 이상 `PENDING` 상태인 파일은 자동 삭제/정리
  - Multipart 방식에서는 업로드 실패 시점에 이미 서버가 흐름을 알고 있으므로 정리 로직이 상대적으로 단순

---

## 8. 도입 전략 제안

- 1단계 (초기)
  - Multipart Upload 방식으로 단일 서버에서 업로드 기능 구현
  - DB 메타데이터 및 기본 삭제(소프트 삭제 + 지연 삭제) 구조 먼저 마련
- 2단계 (확장)
  - 업로드 트래픽 증가 시 “업로드 전용 서비스”로 분리
  - Presigned URL 도입하여 대형 파일/고트래픽 경로를 점진적으로 옮김
  - 후처리는 비동기 이벤트 기반으로 분리
- 3단계 (고도화)
  - CDN 최적화, 썸네일/동적 변환, 서명된 URL/Access Control 강화
  - 파일 버전 관리, 법적 보존 정책, 백업/아카이빙 전략 정교화

