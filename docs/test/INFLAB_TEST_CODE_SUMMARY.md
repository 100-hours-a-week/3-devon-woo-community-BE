# 인프랩 기술 블로그 요약 – 테스트 코드를 왜 그리고 어떻게 작성해야 할까?

> 원문: [테스트 코드를 왜 그리고 어떻게 작성해야 할까?](https://tech.inflab.com/20230404-test-code/)  
> 이 문서는 인프랩 기술 블로그 글을 바탕으로, 테스트 코드의 필요성과 잘 작성하는 방법을 정리한 것입니다.

---

## 1. 테스트 코드를 왜 작성해야 하는가?

글에서는 테스트 코드를 작성해야 하는 이유를 다섯 가지로 정리합니다.

### 1.1 디버깅 비용 절감

- 테스트 코드가 없으면, 버그가 발생할 때마다
  - 로그 추적 → 상황 재현 → 브레이크포인트 설정 → 수동 테스트를 반복해야 합니다.
- 자동화된 테스트가 있다면
  - 재현 과정을 테스트로 고정하고
  - 코드 수정 후 테스트 한 번으로 버그가 해결되었는지 확인할 수 있습니다.
- 결과적으로 **디버깅에 쓰는 시간과 정신적 비용을 크게 줄일 수 있습니다.**

### 1.2 코드 변경에 대한 불안감 해소

- 기능 변경·리팩터링 시 “내가 바꾼 코드가 다른 부분을 깨뜨리지 않을까?”라는 불안감이 생깁니다.
- 자동화 테스트는 **회귀 테스트(Regression Test)** 역할을 하여
  - 기존 기능이 여전히 정상 동작하는지
  - 예상치 못한 부작용이 없는지를 빠르게 검증해 줍니다.
- 이를 통해 **“변경에 강한 코드(내성이 있는 코드)”** 를 만들 수 있습니다.

### 1.3 더 나은 문서 자료

- 문서/위키는 시간이 지나면 실제 코드와 쉽게 어긋납니다.
- 반면 테스트 코드는
  - 실제 코드와 함께 실행되며
  - 실패하면 바로 알 수 있는 “살아있는 문서(living documentation)” 역할을 합니다.
- 특히 **입력-출력 예시가 명시되어 있는 테스트**는
  - 코드의 사용 예시이자
  - 비즈니스 규칙을 설명하는 좋은 레퍼런스가 됩니다.

### 1.4 좋은 코드는 테스트하기 쉽다

- 좋은 코드는 “변경하기 쉬운 코드”이며, 보통 **결합도가 낮고 응집도가 높은 코드**입니다.
- 강하게 결합된 코드(여러 곳에 의존이 얽혀 있는 코드)는
  - 테스트하기도 어렵고
  - 재사용/변경도 어렵습니다.
- 따라서 **테스트 작성 난이도는 코드 품질의 지표**가 될 수 있습니다.
  - “테스트를 작성하기 어렵다면, 코드에 냄새가 날 가능성이 높다.”

### 1.5 테스트 자동화

- 테스트가 없으면 개발자는 배포 시마다 “기도 메타”에 의존하게 됩니다.
  - “내 코드가 정상 동작할까?”
  - “다른 기능은 안 깨졌을까?”
- CI에서 자동화된 테스트를 실행하면
  - 배포 전에 버그를 조기에 차단할 수 있고
  - 프로젝트와 개발자 모두 **심리적인 안정감**을 얻을 수 있습니다.
- 즉, **테스트 자동화는 지속 가능한 프로젝트를 위한 필수 요소**에 가깝습니다.

---

## 2. 테스트 코드를 잘 작성하는 방법 (with Jest)

글의 후반부에서는 Jest와 TypeScript를 예로, “좋은 테스트 코드”를 위한 네 가지 원칙을 제시합니다.

### 2.1 테스트 코드는 DRY보다 DAMP

- 프로덕션 코드에서는 DRY(Don’t Repeat Yourself)를 중시하지만,
  **테스트 코드에서는 DRY가 과하면 오히려 가독성을 해칠 수 있습니다.**
- 대신 DAMP(Descriptive And Meaningful Phrases) 원칙을 사용합니다.
  - “의미 있고 설명적인 구문”을 유지하는 것이 중복 제거보다 중요하다는 뜻입니다.
- 테스트에서 과도하게 헬퍼/공통 함수로 추출하면
  - 각 테스트의 의도가 흐려지고
  - 한 곳을 수정했을 때 여러 테스트가 한 번에 깨지는 문제가 생길 수 있습니다.
- 따라서 **약간의 중복을 허용하더라도, 테스트 본문만 보고도 무슨 상황을 검증하는지 이해 가능하도록 작성**하는 것이 좋습니다.

### 2.2 구현이 아닌 ‘결과’를 검증하라

- 나쁜 테스트의 전형: 내부 구현 세부사항에 강하게 의존하는 테스트
  - 특정 메서드 호출 횟수, 내부 변수 값, 특정 라이브러리 호출 여부 등.
- 구현을 조금만 바꿔도 테스트가 대거 깨지기 때문에, **리팩터링을 방해하는 테스트**가 됩니다.
- 좋은 테스트는 **“외부에서 보이는 행위/결과”** 를 검증합니다.
  - 같은 입력에 대해 동일한 출력/상태 변화가 일어나는지
  - 부수효과(예: DB 저장, 이벤트 발행)가 약속대로 발생하는지
- 이렇게 하면 **내부 구현은 자유롭게 리팩터링하면서도, 기대 동작은 유지**할 수 있습니다.

### 2.3 읽기 좋은 테스트를 작성하라

- 테스트 코드는 결국 “미래의 나/동료”가 읽는 코드입니다.
- 읽기 좋은 테스트를 위해 다음과 같은 점을 강조합니다.
  - **명확한 테스트 이름**: 시나리오와 기대 결과가 드러나게 (`should_xxx_when_yyy` 형태 등).
  - **Given–When–Then 구조**: 준비, 실행, 검증 단계가 명확히 보이도록 코드/주석/빈 줄로 구분.
  - 불필요하게 복잡한 헬퍼/추상화는 지양하고, **테스트 본문에서 맥락이 바로 보이도록** 작성.

### 2.4 테스트 명세에 비즈니스 행위를 담아라

- 테스트의 이름과 본문은 단순한 기술적인 설명이 아니라, **비즈니스 규칙과 행위를 드러내야** 합니다.
  - 예: “포인트가 부족하면 결제가 실패한다”, “하루 최대 요청 수를 초과하면 에러를 반환한다”
- 이렇게 작성된 테스트는
  - 도메인 전문가/기획자와의 커뮤니케이션에도 도움이 되고
  - 요구사항 변경 시 어떤 테스트를 수정해야 할지 쉽게 파악할 수 있게 해 줍니다.
- 한마디로, **테스트를 “비즈니스 명세”로 활용**하는 관점입니다.

---

## 3. 정리 및 우리가 얻을 수 있는 인사이트

이 글을 통해 얻을 수 있는 핵심 메시지는 다음과 같습니다.

1. **테스트는 비용이 아니라 투자**
   - 디버깅/불안감/회귀 버그를 줄이고, 문서 역할까지 수행하는 “종합 보험”입니다.
2. **테스트 난이도는 코드 품질의 시그널**
   - 테스트하기 어려운 코드는 강결합·복잡도 증가 등 문제를 품고 있을 가능성이 큽니다.
3. **테스트 코드에도 별도의 원칙이 필요**
   - DRY보다 DAMP, 구현보다 결과, 기술 설명보다 비즈니스 행위에 초점을 맞춥니다.
4. **테스트 자동화는 지속 가능한 서비스의 핵심**
   - CI에 통합된 자동화 테스트는 배포 안정성과 개발자의 심리적 안전망을 제공합니다.

우리 프로젝트에 적용한다면:

- 테스트가 거의 없는 영역이라면 “디버깅 비용이 큰 기능/불안감이 큰 변경”부터 우선 테스트를 도입합니다.
- 테스트 작성 시, **중복 제거보다 가독성·명확한 시나리오 표현**을 우선합니다.
- 테스트 이름/본문에서 **도메인 언어와 비즈니스 규칙**을 적극적으로 사용해 “살아있는 명세”로 키워갈 수 있습니다.

