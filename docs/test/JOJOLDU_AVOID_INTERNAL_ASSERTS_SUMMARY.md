# 조졸두 블로그 요약 – 테스트 코드에서 내부 구현 검증 피하기

> 원문: [테스트 코드에서 내부 구현 검증 피하기](https://jojoldu.tistory.com/614)  
> 이 문서는 조졸두님의 글을 바탕으로, “내부 구현에 집착하는 테스트”가 왜 위험한지와 이를 피하는 방법을 정리한 것입니다.

---

## 1. 문제의식: 왜 내부 구현을 검증하면 안 되는가

글에서 다루는 대표적인 테스트 스멜은 다음과 같습니다.

- **기능의 최종 결과가 아니라, 내부 구현 세부사항을 검증하는 테스트**
  - 예: 중간 계산용 필드 값, 특정 메서드 호출 횟수, 내부 협력 객체 호출 순서 등.
- 이런 테스트는 구현을 조금만 바꿔도 쉽게 깨집니다.
  - 비즈니스 규칙은 그대로인데, 중간 구현 방법만 바꾼 경우에도 테스트를 많이 고쳐야 합니다.
- 결과적으로 **리팩터링을 방해하는 테스트**가 되어 버리고, 어느 순간부터는 테스트가 “짐”이 되기 시작합니다.

핵심 메시지:

> 내부 구현은 언제든지 바뀔 수 있으므로, 테스트는 내부 구현이 아니라 **최종 결과(행동)** 를 검증해야 한다.

---

## 2. 안티 패턴 1 – 상세 구현부를 모두 검증하는 테스트

글에서는 합계 금액을 계산하는 예시를 통해, 잘못된 테스트 패턴을 설명합니다.

- 예를 들어 `OrderAmountSum` 같은 클래스가 있다고 할 때:
  - `minusSum`, `plusSum` 같은 내부 필드를 테스트가 직접 검증하거나
  - 중간 단계에서 어떤 메서드를 몇 번 호출했는지까지 모두 `verify` 하는 테스트를 작성하는 경우가 있습니다.
- 이런 테스트는
  - “최종적으로 얼마를 반환해야 하는가?”라는 비즈니스 규칙보다
  - “어떻게 계산하는가?”라는 내부 절차에 과도하게 결합됩니다.

이런 테스트의 문제점:

- 새로운 요구사항에 맞게 **구현 방법만 조금 바꿔도 테스트가 우르르 깨짐**.
- 실제로 깨진 테스트가 “동작상의 버그”인지, 아니면 “리팩터링으로 인한 정상적인 변화”인지 구분하기 어렵습니다.

---

## 3. 안티 패턴 2 – Mock/Spy에 과도하게 의존하는 테스트

내부 구현 검증의 또 다른 형태는 **Mock/Spy에 과도하게 의존하는 테스트**입니다.

- 특정 메서드가 몇 번 호출되었는지, 어떤 순서로 호출되었는지, 어떤 인자를 넘겼는지 등
  - “외부에서 보이는 결과”보다 **내부 협력 방식**에 초점을 두는 테스트.
- 이런 테스트는 협력 객체나 협력 방식만 바뀌어도 손쉽게 깨집니다.

문제는:

- 실제로는 더 좋은 설계/구현으로 리팩터링하려고 할 때조차,
  - 테스트가 지속적으로 발목을 잡게 된다는 점입니다.
- 길게 보면 테스트가 “안전망”이 아니라, **변화에 대한 저항 세력**이 됩니다.

---

## 4. 좋은 방향 – “행동/결과” 위주로 테스트하기

글이 제안하는 해법은 단순하지만 강력합니다.

1. **입력과 출력(또는 외부에서 관측 가능한 상태 변화)을 기준으로 테스트를 작성한다.**
   - 같은 입력 → 같은 결과를 기대하는 테스트.
   - 예: `합계 금액 계산`의 경우, 최종 합계 값만 검증.
2. 내부 필드, 내부 메서드 호출, 협력자 호출 순서 등은 테스트에서 “가능하면” 모른 척한다.
   - 진짜 필요한 경우(예: 외부 시스템 호출 횟수 제한 등)를 제외하고는 피합니다.
3. 테스트를 읽었을 때 **“무슨 비즈니스 규칙을 보장하는지”** 가 드러나야 한다.
   - “이 메서드를 두 번 호출해야 한다”가 아니라, “할인 정책이 올바르게 적용되어 총액이 얼마여야 한다”가 초점.

이렇게 하면:

- 내부 구현은 자유롭게 바꾸면서도, **비즈니스 규칙만 안정적으로 보호**할 수 있습니다.
- 리팩터링 시 테스트 수정 비용이 줄고, 테스트가 “안전망” 역할을 유지합니다.

---

## 5. 우리 프로젝트에 적용할 수 있는 체크리스트

이 글의 내용을 바탕으로, 우리 테스트 코드에 적용할 수 있는 간단한 점검 항목을 정리하면 다음과 같습니다.

1. **테스트가 내부 필드나 내부 메서드를 직접 검증하고 있는가?**
   - 가능하면 제거하고, 최종 반환값이나 외부에 드러나는 상태로 전환합니다.
2. **Mock/Spy의 호출 횟수/순서 검증이 정말 비즈니스적으로 의미가 있는가?**
   - 단지 구현을 그대로 따라 쓴 건 아닌지, 다시 한 번 점검합니다.
3. **테스트 이름과 본문이 “동작/규칙”을 설명하고 있는가, 아니면 “구현 절차”를 설명하고 있는가?**
   - 후자라면, 테스트가 과도하게 내부에 결합되어 있을 가능성이 높습니다.
4. **구현을 리팩터링했을 때, 테스트 대부분이 그대로 통과하는가?**
   - 리팩터링을 하면 테스트가 자주 깨진다면, 내부 구현에 의존하는 테스트가 너무 많은지 확인합니다.

---

## 6. 정리

- 테스트는 **내부 구현을 고정하는 도구가 아니라, 비즈니스 동작을 보호하는 안전망**이어야 합니다.
- 내부 구현을 지나치게 검증하는 테스트는:
  - 리팩터링을 방해하고
  - 테스트 유지보수 비용을 높이며
  - 결국 “테스트는 귀찮고 쓸모 없다”는 인식을 강화하게 됩니다.
- 반대로, **행동과 결과 중심으로 작성된 테스트**는:
  - 코드 변경에 유연하게 대응하면서도
  - 중요한 규칙을 안정적으로 지켜 줍니다.

> 결론: 테스트를 작성할 때마다 “지금 이 테스트는 **무엇을 보호하고 있는가?**  
> 동작인가, 아니면 내부 구현인가?”를 스스로에게 물어보자.

