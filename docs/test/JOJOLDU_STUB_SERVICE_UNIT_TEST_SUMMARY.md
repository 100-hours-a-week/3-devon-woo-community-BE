# 조졸두 블로그 요약 – Stub을 이용한 Service 계층 단위 테스트 하기

> 원문: [Stub 을 이용한 Service 계층 단위 테스트 하기](https://jojoldu.tistory.com/637)  
> 이 문서는 조졸두님의 글을 바탕으로, Service 계층을 Stub을 활용해 단위 테스트하는 전략과 주의점을 정리한 것입니다.

---

## 1. 글의 문제의식

- 많은 코드베이스에서 **Service 계층은 통합 테스트 또는 E2E 테스트로만** 검증되는 경우가 많습니다.
- 이 경우:
  - 테스트 속도가 느리고
  - 실패 시 원인 파악이 어렵고
  - 작은 로직 변경도 전체 통합 테스트를 돌려야 하는 부담이 생깁니다.
- 글의 목표:
  - Service 계층에서도 **Stub을 활용한 빠른 단위 테스트**를 적극적으로 사용하자.
  - 단, **테스트 더블의 특성과 단점**을 이해한 상태에서 선택적으로 쓰자.

---

## 2. Stub을 이용한 Service 단위 테스트의 이점

### 2.1 빠르고 명확한 피드백

- Repository, 외부 API 등 인프라 의존성을 **Stub으로 대체**하면:
  - 실제 DB/네트워크 없이 메모리에서만 테스트가 동작합니다.
  - Service 로직의 성공/실패 조건을 빠르게 검증할 수 있습니다.
- 예: `OrderService`가 `OrderRepository`를 주입받을 때,
  - 테스트에서는 간단한 Stub 구현체를 만들어
  - 특정 주문 상태/데이터를 의도적으로 반환하도록 설정합니다.

### 2.2 테스트 대상에 집중

- 통합 테스트는 “전체 플로우”에는 좋지만, **Service 자체의 조건/분기/예외 처리**를 보기에는 노이즈가 많습니다.
- Stub 기반 단위 테스트는:
  - 비즈니스 시나리오별로 **Service의 분기/예외를 직접적으로 검증**할 수 있어
  - “이 Service가 어떤 규칙을 책임지는지”를 명확히 드러냅니다.

---

## 3. 글에서 다루는 예제 구조 (개념 중심)

글에서는 TypeScript + Jest 환경을 기준으로, Service 계층 단위 테스트 예제를 보여줍니다.

- 예제 1: `OrderService.validateCompletedOrder(orderId: number)` 와 같은 메서드가 있다고 가정.
  - 이 메서드는 `OrderRepository`를 이용해 주문을 조회하고,
  - 주문 상태/금액/항목에 따라 예외를 던지거나 정상 처리합니다.
- 단위 테스트에서는:
  - `OrderRepository` 인터페이스를 구현하는 Stub 클래스를 테스트 파일 안에 정의하거나,
  - 테스트용 Stub 구현을 별도 파일로 분리해 재사용합니다.
  - 각 테스트 케이스마다 Stub이 반환할 데이터를 다르게 설정하여
    - 완료된 주문
    - 취소된 주문
    - 존재하지 않는 주문
    - 조건을 만족하지 않는 주문
    등을 시나리오별로 검증합니다.

핵심 포인트:

- Service의 복잡한 분기/검증 로직을 **DB 없이도 충분히** 테스트할 수 있다.
- 이렇게 하면 Service 로직 변경 시 빠르게 테스트를 돌리고, 설계 피드백을 받을 수 있다.

---

## 4. Stub/Mock 등 테스트 더블 사용 시 주의점

글 후반부에서는 Stub을 포함한 **테스트 더블(Test Double)** 사용의 단점과 주의점도 강조합니다.

### 4.1 테스트 더블은 깨지기 쉬운 테스트를 만들기 쉽다

- Stub/Mock을 사용하면, 테스트는 자연스럽게 **구현 세부사항에 더 많이 의존**하게 됩니다.
- 그 결과:
  - 구현을 조금만 바꿔도 Stub/Mock 설정을 모두 고쳐야 하는 상황이 생깁니다.
  - 테스트가 실제 버그를 잡기보다, “구현 변경”에 민감하게 반응하는 **깨지기 쉬운 테스트**가 됩니다.
- 글에서는 관련 글로 [테스트 코드에서 내부 구현 검증 피하기](https://jojoldu.tistory.com/614)를 함께 참고하라고 안내합니다.

### 4.2 가능하면 실제 객체를 우선

- **가능하다면 실제 객체를 사용하는 것이 가장 좋다**는 점을 다시 한 번 강조합니다.
  - 특히 도메인/엔티티/값 객체 등은 테스트 더블 없이 실제 구현으로 검증하는 편이 좋습니다.
- Stub/Mock 등 테스트 더블은:
  - 외부 시스템 의존성이 크거나
  - 테스트 환경에서 다루기 어려운 부분에 한해서 “필요 최소한”으로 사용합니다.

### 4.3 테스트 더블이 필요 없는 작은 구조를 목표로

- 테스트 더블이 많이 필요하다는 것은, 그만큼 **한 객체가 너무 많은 책임을 지고 있거나, 결합도가 높다는 신호**일 수 있습니다.
- 글의 제안:
  - Stub/Mock을 억지로 잘 쓰는 방법만 고민하기보다,
  - **테스트 더블이 거의 필요 없을 정도로 작은·단순한 구조**로 설계를 개선하는 편이 더 낫다.

요약하면:

> Stub/Mock을 “잘 쓰는 것”보다, Stub/Mock이 거의 필요 없는 설계를 만드는 것이 더 좋은 목표다.

---

## 5. 우리 프로젝트에 적용해볼 수 있는 방향

이 글에서 얻을 수 있는 실질적인 적용 포인트를 정리하면 다음과 같습니다.

1. **Service 로직을 전부 통합 테스트로만 검증하지 않기**
   - 복잡한 분기/검증/정책을 담고 있는 Service는 Stub 기반 단위 테스트를 추가해,
   - 빠르고 세밀한 피드백을 받도록 합니다.
2. **Repository/외부 API를 Stub으로 대체한 Service 단위 테스트 도입**
   - Repository 인터페이스에 대해 간단한 메모리 기반 Stub을 만들고,
   - Service의 각 시나리오(성공/실패/예외)를 집중적으로 검증합니다.
3. **Stub/Mock 남용 주의**
   - 사이드 이펙트가 크거나 구현 세부사항에 강하게 의존하는 Stub/Mock 설정은 가급적 줄이고,
   - 필요한 경우에만 신중히 사용합니다.
4. **설계 개선 신호로 활용**
   - “Stub 없이는 테스트가 너무 어렵다”면 설계를 점검합니다.
   - 책임을 분리하고, 도메인/정책 로직을 더 작은 단위로 쪼개서, 테스트 더블 없이도 테스트하기 쉬운 구조를 목표로 합니다.

---

## 6. 정리

- 이 글은 “Service 계층도 Stub을 활용해 충분히 단위 테스트할 수 있다”는 점을 구체적인 예제와 함께 보여 줍니다.
- 동시에, Stub/Mock 같은 테스트 더블이 **깨지기 쉬운 테스트**를 만들 수 있다는 단점도 분명히 짚습니다.
- 결론적으로:
  - **Service의 복잡한 비즈니스 로직은 Stub 기반 단위 테스트로 빠르게 검증**하고,
  - **테스트 더블 사용은 최소화하되, 필요할 때는 의도적으로 사용**하며,
  - **궁극적으로는 테스트 더블이 거의 필요 없는 작은 구조**를 향해 설계를 개선하는 것이 바람직하다는 메시지를 전달합니다.

