# 카카오페이 기술 블로그 요약 – 테스트 코드로부터 피드백 받기 (Mock Part 2)

> 원문: [실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 2: 테스트 코드로부터 피드백 받기](https://tech.kakaopay.com/post/mock-test-code-part-2/)  
> 이 문서는 카카오페이 정산플랫폼팀 글을 바탕으로, 테스트 코드가 설계와 아키텍처에 주는 피드백을 정리한 것입니다.

---

## 1. 글의 문제의식: 테스트 코드는 “알람”이다

- Part 1에서는 Mock/MockBean/@TestConfiguration을 활용해 **효율적으로 테스트를 작성하는 방법**에 초점을 맞췄습니다.
- Part 2에서는 한 단계 더 나아가,
  - 테스트 코드가 **설계와 아키텍처에 주는 피드백**에 주목합니다.
- 핵심 메시지:
  - “테스트 코드가 작성/유지보수하기 어렵다면, 코드 설계에 문제가 있을 가능성이 높다.”
  - 테스트를 억지로 맞추기보다, **테스트가 힘든 이유를 설계 개선의 힌트**로 삼아야 합니다.

---

## 2. 피드백 1 – HTTP Client의 책임과 테스트 범위 정렬하기

### 2.1 초기 상황: HTTP + 비즈니스 로직이 섞인 Client

- `PartnerClient` 가 다음과 같은 역할을 동시에 수행한다고 가정합니다.
  - 외부 API 호출(HTTP 통신)
  - 예외/에러 처리
  - 비즈니스 규칙 일부 적용
- 이 상태에서 HTTP 통신을 Mock Server로 테스트하려고 하면,
  - URL, Method, Header, Body, Response JSON 뿐 아니라
  - 비즈니스 규칙까지 한 번에 검증하려다 보니
  - 테스트가 복잡하고 길어집니다.

### 2.2 테스트로부터 받은 피드백

- “HTTP 호출을 검증하려는 테스트인데, 왜 이렇게 많은 비즈니스 로직까지 신경 써야 하지?”
- 이는 곧 **클라이언트 객체의 책임이 너무 많다**는 신호입니다.

### 2.3 리팩터링 방향

- `PartnerClient` 의 책임을 “HTTP 통신”으로 좁히고, 나머지 비즈니스 로직은 다른 객체로 위임합니다.
  - `PartnerClient` → URL / HTTP Method / Request/Response 매핑만 책임.
  - 예외 처리나 비즈니스 판정은 별도 서비스/도메인 객체가 담당.
- 그 결과:
  - `PartnerClient` 테스트는 Mock Server로 **HTTP 관점만** 집중해서 검증.
  - 비즈니스 로직 테스트는 Mock/Stub된 `PartnerClient` 를 사용해 별도로 검증.

**정리**
- 테스트가 “이 객체를 어떻게 나눠야 할지”를 알려주는 피드백 도구가 됩니다.

---

## 3. 피드백 2 – 과도한 책임을 가진 Service 쪼개기

### 3.1 복잡한 OrderService 예시

- 예제의 `OrderService` 는 다음과 같은 다양한 인프라 의존성을 동시에 다룹니다.
  - 상품 정보: Elasticsearch
  - 환율 정보: Redis 또는 외부 환율 API
  - 쿠폰 정보: MySQL
  - 가맹점 정보: MySQL
- 주문 처리 과정에서:
  - 재고 확인, 환율 계산, 쿠폰 적용 조건/부담 비율 계산,
  - 가맹점 상태/수수료 조회, 예외 처리 등 **복잡한 비즈니스 로직**이 모두 한 클래스에 모여 있습니다.

### 3.2 테스트 케이스 다양성과 난이도

- 주문 시나리오 예:
  - 상품 재고가 없는 경우
  - 환율 정보를 가져오지 못한 경우
  - 환율을 적용한 최종 결제 금액 계산
  - 특정 가맹점에 쿠폰을 적용하지 못하는 경우
  - 만료된 쿠폰 예외
  - 폐업 처리된 가맹점 예외
  - 필수 가맹점 정보를 가져오지 못한 경우 등
- 이 모든 케이스를 `OrderService` 하나의 테스트로 다루려면,
  - 여러 인프라에 걸친 데이터 셋업이 필요하고
  - Given 절이 매우 길고 복잡해집니다.

### 3.3 테스트 코드가 주는 피드백

- “시나리오 하나를 테스트하려고 해도 준비 코드가 너무 많다.”
- “특정 케이스만 다루고 싶은데도, 여러 인프라 의존성을 항상 같이 고려해야 한다.”
- 이는 곧 **OrderService 하나에 책임과 관심사가 과도하게 집중되어 있다**는 신호입니다.

### 3.4 리팩터링 방향: 책임 분산을 위한 협력 객체 추가

- 컨베이어 벨트 비유:
  - 모든 작업자가 각자 일을 잘하고 있는데도 작업이 힘들다면, **새로운 작업자를 추가해 일을 분산**해야 합니다.
- 객체 설계에서도 마찬가지로,
  - `OrderService` 의 책임을 도와줄 협력 객체를 도입해 역할을 나눕니다.
- 예시 방향:
  - `ProductPolicy`, `CouponPolicy`, `ShopPolicy` 같은 도메인 서비스/정책 객체로 규칙을 분리.
  - `OrderCalculator`, `PricingService` 등 금액/환율 계산 책임 분리.
- 이렇게 분리하면:
  - 각 객체는 더 좁은 책임과 관심사를 갖게 되고,
  - 테스트는 그 책임 범위 안에서만 집중적으로 작성 가능.
  - Given 절이 단순해지고, 테스트 케이스 작성이 쉬워집니다.

**정리**
- “테스트 코드 작성이 너무 어렵다”는 느낌은,
  - 클래스에 책임이 과하게 집중되었다는 강력한 신호입니다.

---

## 4. 테스트 코드로부터 설계 피드백을 받는 태도

글이 강조하는 태도는 다음과 같습니다.

1. **테스트 작성 난이도를 설계 지표로 활용하기**
   - 테스트 작성이 자연스럽고 단순하다 → 책임이 잘 분리되었을 가능성이 높음.
   - 테스트 작성이 힘들고 셋업이 과도하다 → 책임 분리/구조 개선이 필요할 수 있음.

2. **테스트를 억지로 맞추지 말고 설계를 되돌아보기**
   - Mock/Stub/Fixture로 억지로 테스트를 통과시키는 대신,
   - “왜 이렇게 많은 것들을 준비해야 하지?”를 스스로에게 물어보고
   - 객체 간 협력/역할 분배를 다시 설계합니다.

3. **관심사를 따라 테스트 계층을 나누기**
   - HTTP 통신 책임 → Client + Mock Server 테스트.
   - 비즈니스 규칙 책임 → 도메인/서비스 단위 테스트(Stub/Mock 인프라).
   - 인프라 설정/연동 → 통합/인수 테스트.

---

## 5. 우리 프로젝트에 적용할 수 있는 포인트

이 글에서 얻을 수 있는 실질적인 인사이트를 우리 코드베이스에 적용해보면:

1. **테스트 쓰기 어려운 클래스는 설계 냄새 후보로 본다.**
   - 테스트 셋업이 과도하게 복잡한 Service/Controller/Client는
   - 책임을 더 잘게 나눌 수 없는지 검토합니다.

2. **Client/Adapter 계층의 책임을 명확히**
   - HTTP/DB/외부 시스템 연동 객체는
     - 통신 + 직렬화/역직렬화까지만 책임지도록 하고,
     - 도메인 규칙은 별도 서비스/도메인 객체에서 담당하게 합니다.

3. **복잡한 플로우를 여러 협력 객체로 분리**
   - 하나의 Service가 “상품/환율/쿠폰/가맹점/정책”을 모두 담당한다면,
   - 이를 도메인 서비스/정책/계산기 등의 협력 객체로 분리해
   - 각 부분별로 따로 테스트 가능하게 합니다.

4. **테스트와 설계를 함께 리팩터링**
   - 운영 코드 구조가 바뀌면 테스트도 함께 수정하고,
   - 반대로 테스트가 주는 피드백(작성 난이도, 중복, 냄새)을 토대로
   - 운영 코드를 리팩터링하는 선순환을 만듭니다.

---

## 6. 정리

- 이 글의 핵심은 “Mock을 더 잘 쓰는 방법”이 아니라,
  - **Mock/테스트 코드가 설계 개선 방향을 알려주는 피드백 도구**라는 점입니다.
- 테스트 코드가:
  - 복잡하고 쓰기 어렵고 이해하기 힘들다면, 설계를 돌아봐야 합니다.
  - 작고 명확하고 집중되어 있다면, 설계가 잘 분해되어 있을 가능성이 높습니다.
- 결국 좋은 테스트 전략이란,
  - 테스트와 설계가 서로 피드백을 주고받으며 함께 성장하는 구조를 만드는 것입니다.

