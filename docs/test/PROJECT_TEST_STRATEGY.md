# 우리 프로젝트 테스트 전략 (정리본)

> 목적: 지금까지 참고한 글(Toss, 카카오페이, 조졸두 등)에서 얻은 인사이트를 **우리 프로젝트에 맞게** 재구성한 실천 가이드. “왜 이렇게 하는지”를 분명히 하여 팀 내 일관성을 확보한다.

---

## 1) 목표와 방향성

- **빠른 피드백 + 높은 신뢰도**: 자주 돌릴 수 있는 속도, 실패 시 원인 파악이 쉬운 구조.
- **테스트가 설계를 끌어올리게**: 테스트하기 어렵다면 설계 개선 신호로 받아들인다.
- **중복 최소화, 재사용 극대화**: Given/Fixture/의존성 관리까지 구조적으로 다룬다.

---

## 2) 전체 아키텍처에 맞춘 테스트 레이어

프로젝트는 Spring Boot 기반 서버(도메인 로직 + JPA + 외부 연동) 중심이다. 테스트 피라미드를 다음처럼 구성한다.

1. **유닛 테스트 (가장 많음)**
   - 대상: 도메인 객체(@Entity 포함) 메서드, 정책/검증/계산 로직, 서비스의 분기·예외 처리.
   - 의존성: DB/HTTP 없이 Stub/Fake 또는 인메모리 대체물 사용.
   - 이유: 비즈니스 규칙이 잦은 변경 대상이고, 빠른 피드백이 중요하다.

2. **통합 테스트 (필요한 만큼)**
   - 대상: JPA 매핑·쿼리, 트랜잭션, 스프링 빈 설정, 보안/필터/AOP, 주요 서비스-리포지토리 연결.
   - 의존성: 내장 DB(H2 등) 또는 Testcontainer, 스프링 컨텍스트 실제 구동.
   - 이유: 설정/쿼리/빈 연결 문제를 조기에 발견.

3. **인수(E2E) 테스트 (핵심 시나리오 위주, 적지만 강하게)**
   - 대상: 주요 API 플로우(예: 게시글 작성/수정/조회, 좋아요/조회수 정책 등).
   - 의존성: 실제 HTTP 호출(MockMvc/RestAssured), 필요한 외부는 Fake/Stub로 대체.
   - 이유: 사용자 관점 신뢰도 확보, 회귀 방지.

---

## 3) 테스트 더블 & Mock 전략

- **내부 구현 검증 금지**: 호출 횟수/순서보다 “결과/행동”을 검증. (조졸두 글의 교훈)
- **외부 서비스 연동**
  - 토스/카카오페이 전략 참고: 가능하면 실제 객체, 부수효과 크면 Dummy, 조작 필요 시 Stub/Fake, 불가피할 때만 Mock.
  - HTTP 클라이언트는 책임을 “통신”으로 좁혀서 테스트: Mock 서버로 HTTP 부분만 검증, 비즈니스 로직은 별도 서비스에서 검증.
- **@MockBean 최소화**
  - 남용 시 Application Context 재초기화로 느려짐. (카카오페이 Part 1)
  - 대안: `@TestConfiguration + @Primary` 로 테스트용 Bean을 등록해 컨텍스트 재사용, 또는 유닛 테스트에서 가벼운 Stub 사용.
- **설계 피드백**
  - 테스트 작성이 과하게 힘들면 책임 분산(협력 객체 추가) 검토. (카카오페이 Part 2)

---

## 4) Given/Fixture 관리 (Given 지옥 탈출)

- **테스트 데이터 빌더/헬퍼 도입**: 필수 차이만 인자로 받고 나머지는 기본값으로 채우는 `given*` 함수/빌더 사용.
- **중복 제거 & 가독성 유지**: DRY보다 DAMP(의미 있고 설명적인 구문). 헬퍼는 의도 파악에 도움을 줘야 한다.
- **외부 인프라 Mocking 캡슐화**: Request/Response 매핑이 긴 경우 헬퍼로 감추고, 테스트 본문은 핵심만 남긴다.

---

## 5) Gradle 테스트 의존성/Fixture 공유 전략

프로젝트가 멀티 모듈이거나 테스트 리소스를 여러 계층에서 재사용해야 할 경우:

- **java-test-fixtures 활용**
  - 테스트 전용 Builder/Helper는 `src/testFixtures` 로 이동.
  - 다른 모듈 테스트에서 재사용: `testImplementation(testFixtures(project(":module")))`.
  - 장점: 테스트 전용 클래스만 노출, 테스트 본문(@Test)은 노출 안 됨.
- **테스트 전용 의존성 전파**
  - 예: `db` 모듈에 H2를 `testFixturesRuntimeOnly` 로 추가 → 상위 모듈에서 `testRuntimeOnly(testFixtures(project(":db")))` 로 가져옴.
  - 이유: 상위 모듈이 DB 선택/세부 설정에 관심 갖지 않으면서도 통합 테스트를 동일하게 돌릴 수 있게 함.

단일 모듈이어도 `testFixtures` 를 써서 인수/통합/단위 테스트 간 Builder/Fixture 중복을 줄일 수 있다.

---

## 6) 계층별 적용 가이드 (우리 코드 기준)

- **도메인(엔티티/정책/유틸)**: 유닛 테스트로 촘촘히. DB/스프링 의존 제거, 순수 객체로 검증.
- **서비스**:
  - 복잡한 분기/정책은 유닛 테스트(Stub 리포지토리).
  - 스프링 빈 연결/트랜잭션/쿼리 영향을 보는 테스트는 통합 테스트로 별도 작성.
  - 외부 클라이언트 의존 시 인터페이스로 분리, 단위 테스트는 Fake/Mock으로 주입.
- **리포지토리/JPA**: `@DataJpaTest` 등으로 매핑/쿼리/트랜잭션 검증. 중요 쿼리는 경계값/예외 포함.
- **컨트롤러/필터/보안**: 핵심 플로우는 인수 테스트로, 세부 필터/시큐리티 설정은 슬라이스 테스트(`@WebMvcTest`, 필요시 `@SpringBootTest`).
- **설정/인프라**: 로깅, 보안 설정, AOP 등은 통합 테스트로 실제 빈 구동 확인.

---

## 7) 커버리지와 품질 기준

- **커버리지 숫자보다 위치**: 핵심 도메인/금전/권한/정책 로직은 90%+ 목표, 단순 DTO/위임은 과도한 집착 금지.
- **Self-validating**: 로그 의존 금지, 명시적 assert/예외 검증.
- **테스트 이름/구조**: Given–When–Then을 코드로 드러내고, 시나리오와 기대 결과를 제목에 담는다.
- **리팩터링 동반**: 테스트/프로덕션 코드 함께 리팩터링. 테스트가 설계 개선을 이끈다는 관점 유지.

---

## 8) 실행 우선순위 (단기 액션 아이템)

1. **testFixtures 디렉터리 도입**: 공용 빌더/헬퍼(`given*`) 정리, 인수/통합/단위에서 재사용.
2. **서비스 단위 테스트 확대**: Stub 리포지토리/클라이언트로 빠르고 명확한 테스트 확보.
3. **@MockBean 정리**: 느린 컨텍스트 재초기화 테스트는 `@TestConfiguration + @Primary` Mock Bean으로 전환 검토.
4. **주요 플로우 인수 테스트 확보**: 게시글/좋아요/조회수/권한 등 핵심 시나리오 1~2개씩 작성.
5. **JPA 통합 테스트 보강**: 매핑/쿼리/트랜잭션 경계값 케이스 추가.
6. **테스트 의존성/Fixture 공유 설정**: 멀티 모듈이면 `java-test-fixtures` 적용, 아니어도 testFixtures로 중복 최소화.

---

## 9) 요약

- “테스트가 힘들다”는 것은 설계 개선 신호다. 책임을 쪼개고, 테스트 더블 남용을 줄이고, Given/Fixture를 구조화한다.
- java-test-fixtures로 **테스트 코드와 의존성**을 일관되게 관리해 중복과 지옥을 피한다.
- 피라미드는 **유닛 많고, 통합은 필요한 만큼, 인수는 핵심 위주**로 유지한다.
- 항상 “이 테스트가 보호하는 것은 내부 구현인가, 비즈니스 동작인가?”를 자문한다. 동작을 보호하는 테스트가 우리에게 필요한 테스트다.

